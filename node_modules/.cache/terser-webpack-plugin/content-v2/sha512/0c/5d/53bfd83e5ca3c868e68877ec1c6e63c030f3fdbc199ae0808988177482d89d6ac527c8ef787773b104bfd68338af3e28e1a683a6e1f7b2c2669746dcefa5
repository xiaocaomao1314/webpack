{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{25:function(n,t,r){\"use strict\";if(r(8)){var e=r(30),i=r(1),o=r(2),u=r(0),f=r(59),c=r(84),l=r(17),a=r(42),s=r(28),h=r(14),g=r(43),v=r(19),d=r(6),p=r(117),y=r(32),w=r(26),S=r(13),b=r(46),E=r(4),_=r(10),L=r(76),P=r(33),m=r(35),T=r(34).f,A=r(78),F=r(29),O=r(5),x=r(22),B=r(49),R=r(47),I=r(80),M=r(40),W=r(52),k=r(41),N=r(79),Y=r(108),j=r(9),D=r(20),V=j.f,C=D.f,J=i.RangeError,U=i.TypeError,G=i.Uint8Array,q=\"ArrayBuffer\",z=\"SharedArrayBuffer\",H=\"BYTES_PER_ELEMENT\",K=Array.prototype,Q=c.ArrayBuffer,X=c.DataView,Z=x(0),$=x(2),nn=x(3),tn=x(4),rn=x(5),en=x(6),on=B(!0),un=B(!1),fn=I.values,cn=I.keys,ln=I.entries,an=K.lastIndexOf,sn=K.reduce,hn=K.reduceRight,gn=K.join,vn=K.sort,dn=K.slice,pn=K.toString,yn=K.toLocaleString,wn=O(\"iterator\"),Sn=O(\"toStringTag\"),bn=F(\"typed_constructor\"),En=F(\"def_constructor\"),_n=f.CONSTR,Ln=f.TYPED,Pn=f.VIEW,mn=\"Wrong length!\",Tn=x(1,(function(n,t){return Bn(R(n,n[En]),t)})),An=o((function(){return 1===new G(new Uint16Array([1]).buffer)[0]})),Fn=!!G&&!!G.prototype.set&&o((function(){new G(1).set({})})),On=function(n,t){var r=v(n);if(r<0||r%t)throw J(\"Wrong offset!\");return r},xn=function(n){if(E(n)&&Ln in n)return n;throw U(n+\" is not a typed array!\")},Bn=function(n,t){if(!E(n)||!(bn in n))throw U(\"It is not a typed array constructor!\");return new n(t)},Rn=function(n,t){return In(R(n,n[En]),t)},In=function(n,t){for(var r=0,e=t.length,i=Bn(n,e);e>r;)i[r]=t[r++];return i},Mn=function(n,t,r){V(n,t,{get:function(){return this._d[r]}})},Wn=function(n){var t,r,e,i,o,u,f=_(n),c=arguments.length,a=c>1?arguments[1]:void 0,s=void 0!==a,h=A(f);if(null!=h&&!L(h)){for(u=h.call(f),e=[],t=0;!(o=u.next()).done;t++)e.push(o.value);f=e}for(s&&c>2&&(a=l(a,arguments[2],2)),t=0,r=d(f.length),i=Bn(this,r);r>t;t++)i[t]=s?a(f[t],t):f[t];return i},kn=function(){for(var n=0,t=arguments.length,r=Bn(this,t);t>n;)r[n]=arguments[n++];return r},Nn=!!G&&o((function(){yn.call(new G(1))})),Yn=function(){return yn.apply(Nn?dn.call(xn(this)):xn(this),arguments)},jn={copyWithin:function(n,t){return Y.call(xn(this),n,t,arguments.length>2?arguments[2]:void 0)},every:function(n){return tn(xn(this),n,arguments.length>1?arguments[1]:void 0)},fill:function(n){return N.apply(xn(this),arguments)},filter:function(n){return Rn(this,$(xn(this),n,arguments.length>1?arguments[1]:void 0))},find:function(n){return rn(xn(this),n,arguments.length>1?arguments[1]:void 0)},findIndex:function(n){return en(xn(this),n,arguments.length>1?arguments[1]:void 0)},forEach:function(n){Z(xn(this),n,arguments.length>1?arguments[1]:void 0)},indexOf:function(n){return un(xn(this),n,arguments.length>1?arguments[1]:void 0)},includes:function(n){return on(xn(this),n,arguments.length>1?arguments[1]:void 0)},join:function(n){return gn.apply(xn(this),arguments)},lastIndexOf:function(n){return an.apply(xn(this),arguments)},map:function(n){return Tn(xn(this),n,arguments.length>1?arguments[1]:void 0)},reduce:function(n){return sn.apply(xn(this),arguments)},reduceRight:function(n){return hn.apply(xn(this),arguments)},reverse:function(){for(var n,t=this,r=xn(t).length,e=Math.floor(r/2),i=0;i<e;)n=t[i],t[i++]=t[--r],t[r]=n;return t},some:function(n){return nn(xn(this),n,arguments.length>1?arguments[1]:void 0)},sort:function(n){return vn.call(xn(this),n)},subarray:function(n,t){var r=xn(this),e=r.length,i=y(n,e);return new(R(r,r[En]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===t?e:y(t,e))-i))}},Dn=function(n,t){return Rn(this,dn.call(xn(this),n,t))},Vn=function(n){xn(this);var t=On(arguments[1],1),r=this.length,e=_(n),i=d(e.length),o=0;if(i+t>r)throw J(mn);for(;o<i;)this[t+o]=e[o++]},Cn={entries:function(){return ln.call(xn(this))},keys:function(){return cn.call(xn(this))},values:function(){return fn.call(xn(this))}},Jn=function(n,t){return E(n)&&n[Ln]&&\"symbol\"!=typeof t&&t in n&&String(+t)==String(t)},Un=function(n,t){return Jn(n,t=w(t,!0))?s(2,n[t]):C(n,t)},Gn=function(n,t,r){return!(Jn(n,t=w(t,!0))&&E(r)&&S(r,\"value\"))||S(r,\"get\")||S(r,\"set\")||r.configurable||S(r,\"writable\")&&!r.writable||S(r,\"enumerable\")&&!r.enumerable?V(n,t,r):(n[t]=r.value,n)};_n||(D.f=Un,j.f=Gn),u(u.S+u.F*!_n,\"Object\",{getOwnPropertyDescriptor:Un,defineProperty:Gn}),o((function(){pn.call({})}))&&(pn=yn=function(){return gn.call(this)});var qn=g({},jn);g(qn,Cn),h(qn,wn,Cn.values),g(qn,{slice:Dn,set:Vn,constructor:function(){},toString:pn,toLocaleString:Yn}),Mn(qn,\"buffer\",\"b\"),Mn(qn,\"byteOffset\",\"o\"),Mn(qn,\"byteLength\",\"l\"),Mn(qn,\"length\",\"e\"),V(qn,Sn,{get:function(){return this[Ln]}}),n.exports=function(n,t,r,c){var l=n+((c=!!c)?\"Clamped\":\"\")+\"Array\",s=\"get\"+n,g=\"set\"+n,v=i[l],y=v||{},w=v&&m(v),S=!v||!f.ABV,_={},L=v&&v.prototype,A=function(n,r){V(n,r,{get:function(){return function(n,r){var e=n._d;return e.v[s](r*t+e.o,An)}(this,r)},set:function(n){return function(n,r,e){var i=n._d;c&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[g](r*t+i.o,e,An)}(this,r,n)},enumerable:!0})};S?(v=r((function(n,r,e,i){a(n,v,l,\"_d\");var o,u,f,c,s=0,g=0;if(E(r)){if(!(r instanceof Q||(c=b(r))==q||c==z))return Ln in r?In(v,r):Wn.call(v,r);o=r,g=On(e,t);var y=r.byteLength;if(void 0===i){if(y%t)throw J(mn);if((u=y-g)<0)throw J(mn)}else if((u=d(i)*t)+g>y)throw J(mn);f=u/t}else f=p(r),o=new Q(u=f*t);for(h(n,\"_d\",{b:o,o:g,l:u,e:f,v:new X(o)});s<f;)A(n,s++)})),L=v.prototype=P(qn),h(L,\"constructor\",v)):o((function(){v(1)}))&&o((function(){new v(-1)}))&&W((function(n){new v,new v(null),new v(1.5),new v(n)}),!0)||(v=r((function(n,r,e,i){var o;return a(n,v,l),E(r)?r instanceof Q||(o=b(r))==q||o==z?void 0!==i?new y(r,On(e,t),i):void 0!==e?new y(r,On(e,t)):new y(r):Ln in r?In(v,r):Wn.call(v,r):new y(p(r))})),Z(w!==Function.prototype?T(y).concat(T(w)):T(y),(function(n){n in v||h(v,n,y[n])})),v.prototype=L,e||(L.constructor=v));var F=L[wn],O=!!F&&(\"values\"==F.name||null==F.name),x=Cn.values;h(v,bn,!0),h(L,Ln,l),h(L,Pn,!0),h(L,En,v),(c?new v(1)[Sn]==l:Sn in L)||V(L,Sn,{get:function(){return l}}),_[l]=v,u(u.G+u.W+u.F*(v!=y),_),u(u.S,l,{BYTES_PER_ELEMENT:t}),u(u.S+u.F*o((function(){y.of.call(v,1)})),l,{from:Wn,of:kn}),H in L||h(L,H,t),u(u.P,l,jn),k(l),u(u.P+u.F*Fn,l,{set:Vn}),u(u.P+u.F*!O,l,Cn),e||L.toString==pn||(L.toString=pn),u(u.P+u.F*o((function(){new v(1).slice()})),l,{slice:Dn}),u(u.P+u.F*(o((function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()}))||!o((function(){L.toLocaleString.call([1,2])}))),l,{toLocaleString:Yn}),M[l]=O?F:x,e||O||h(L,wn,x)}}else n.exports=function(){}}}]);","name":"vendors~main~23858e90.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[22],{\n\n/***/ 25:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nif (__webpack_require__(8)) {\n  var LIBRARY = __webpack_require__(30);\n  var global = __webpack_require__(1);\n  var fails = __webpack_require__(2);\n  var $export = __webpack_require__(0);\n  var $typed = __webpack_require__(59);\n  var $buffer = __webpack_require__(84);\n  var ctx = __webpack_require__(17);\n  var anInstance = __webpack_require__(42);\n  var propertyDesc = __webpack_require__(28);\n  var hide = __webpack_require__(14);\n  var redefineAll = __webpack_require__(43);\n  var toInteger = __webpack_require__(19);\n  var toLength = __webpack_require__(6);\n  var toIndex = __webpack_require__(117);\n  var toAbsoluteIndex = __webpack_require__(32);\n  var toPrimitive = __webpack_require__(26);\n  var has = __webpack_require__(13);\n  var classof = __webpack_require__(46);\n  var isObject = __webpack_require__(4);\n  var toObject = __webpack_require__(10);\n  var isArrayIter = __webpack_require__(76);\n  var create = __webpack_require__(33);\n  var getPrototypeOf = __webpack_require__(35);\n  var gOPN = __webpack_require__(34).f;\n  var getIterFn = __webpack_require__(78);\n  var uid = __webpack_require__(29);\n  var wks = __webpack_require__(5);\n  var createArrayMethod = __webpack_require__(22);\n  var createArrayIncludes = __webpack_require__(49);\n  var speciesConstructor = __webpack_require__(47);\n  var ArrayIterators = __webpack_require__(80);\n  var Iterators = __webpack_require__(40);\n  var $iterDetect = __webpack_require__(52);\n  var setSpecies = __webpack_require__(41);\n  var arrayFill = __webpack_require__(79);\n  var arrayCopyWithin = __webpack_require__(108);\n  var $DP = __webpack_require__(9);\n  var $GOPD = __webpack_require__(20);\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n\n\n/***/ })\n\n}]);","inputSourceMap":null}